# -*- coding: utf-8 -*-
"""Regression_NoFramework.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1C5ASbUSoQZoj4Byj_YlezoZ6SCAiG_-X
"""



import sklearn
import kagglehub
import pandas as pd
import os
import numpy as np
from sklearn.model_selection import train_test_split
import plotly.express as px
import plotly.graph_objects as go

model_chosen = input('que modelo quieres usar? (1: KNN sin framework, 2: KNN con sklearn, 3: ambos) ')
valid_choices = ['1', '2', '3', 'ambos', 'both']
if model_chosen not in valid_choices:
    raise ValueError("Modelo no válido. Por favor, elige 1, 2 o 3 (ambos).")
handle = "yasserh/wine-quality-dataset"
path = kagglehub.dataset_download(handle)

# Find a CSV file in the downloaded path (prefer WineQT.csv)
csv_candidates = [f for f in os.listdir(path) if f.lower().endswith(".csv")]
if not csv_candidates:
    raise FileNotFoundError(f"No CSV files found in downloaded dataset directory: {path}")

# Prefer WineQT.csv if present, else take the first CSV
csv_name = next((f for f in csv_candidates if f.lower() == "wineqt.csv"), csv_candidates[0])
csv_file_path = os.path.join(path, csv_name)

# Read the CSV directly from the downloaded location
df = pd.read_csv(csv_file_path)

# Drop 'Id' column if it exists (not all copies include it)
if "Id" in df.columns:
    df = df.drop(["Id"], axis=1)  # La columna Id no tiene ningun dato relevante
df.head()
# Remove duplicate rows (if any) before splitting
df = df.drop_duplicates()

X_train, X_test, y_train, y_test = train_test_split(
    df.drop('quality', axis=1),
    df['quality'],
    test_size=0.2,
    random_state=42
)

#Preguntar si el usuario quiere ver los plots
if input("¿Quieres ver los plots del dataset? (son varios) (s/n): ") =='s':
  import matplotlib.pyplot as plt
  import seaborn as sns
  plt.figure(figsize=(12,7))
  sns.countplot(x='quality', data=df, palette='Greens_d')
  plt.show()
  plt.figure(figsize=(12,7))
  sns.heatmap(df.corr(), annot=True, cmap='Reds')
  plt.show()
  plt.figure(figsize=(12,7))
  sns.scatterplot(x='total sulfur dioxide', y='free sulfur dioxide', data=df)
  plt.show()
  plt.figure(figsize=(12,7))
  sns.violinplot(x='quality', y='volatile acidity', data=df, hue='quality')
  plt.show()
  plt.figure(figsize=(12,7))
  sns.boxplot(x='quality', y='sulphates', data=df, hue='quality')
  plt.show()
  plt.figure(figsize=(12,7))
  sns.boxplot(x='quality', y='alcohol', data=df)
  plt.show()

def manhattan_distance(point1, point2):
    return np.sum(np.abs(point1 - point2))

def get_neighbors(test_point, X_train, y_train, k):
    distances = []
    for i in range(len(X_train)):
        train_point = X_train.iloc[i]
        distance = manhattan_distance(test_point, train_point)
        distances.append((distance, train_point, y_train.iloc[i]))

    distances.sort(key=lambda x: x[0])
    k_nearest_neighbors = distances[:k]
    return k_nearest_neighbors

def predict(neighbors):
    quality_values = [neighbor[2] for neighbor in neighbors]
    average_quality = sum(quality_values) / len(quality_values)
    return average_quality

class KNN:
    def __init__(self, k=5):
        self.k = k
        self.X_train = None
        self.y_train = None

    def fit(self, X_train, y_train):
        self.X_train = X_train
        self.y_train = y_train

    def predict(self, X_test):
        predictions = []
        for i in range(len(X_test)):
            test_point = X_test.iloc[i]
            neighbors = get_neighbors(test_point, self.X_train, self.y_train, self.k)
            prediction = predict(neighbors)
            predictions.append(prediction)
        return np.array(predictions)

from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error
import numpy as np

X_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size=0.25, random_state=42)

# Build model registry
models = {}
if model_chosen in ['1', '3', 'ambos', 'both']:
    models['KNN_sinFramework_k9'] = KNN(k=9)
if model_chosen in ['2', '3', 'ambos', 'both']:
    import sklearn.neighbors
    models['KNN_sklearn_k9'] = sklearn.neighbors.KNeighborsRegressor(n_neighbors=9)

for name, model in models.items():
    print(f"\nEntrenando {name}...")
    model.fit(X_train, y_train)

    y_pred_train = model.predict(X_train)
    y_pred_val = model.predict(X_val)
    y_pred_test = model.predict(X_test)

    r2_train = r2_score(y_train, y_pred_train)
    mae_train = mean_absolute_error(y_train, y_pred_train)
    mse_train = mean_squared_error(y_train, y_pred_train)
    rmse_train = np.sqrt(mse_train)

    r2_val = r2_score(y_val, y_pred_val)
    mae_val = mean_absolute_error(y_val, y_pred_val)
    mse_val = mean_squared_error(y_val, y_pred_val)
    rmse_val = np.sqrt(mse_val)

    r2_test = r2_score(y_test, y_pred_test)
    mae_test = mean_absolute_error(y_test, y_pred_test)
    mse_test = mean_squared_error(y_test, y_pred_test)
    rmse_test = np.sqrt(mse_test)

    print(f"\n===== Resultados para {name} =====")
    print("Training Set Evaluation:")
    print(f"  R-squared score: {r2_train}")
    print(f"  Mean Absolute Error: {mae_train}")
    print(f"  Mean Squared Error: {mse_train}")
    print(f"  Root Mean Squared: {rmse_train}")

    print("\nValidation Set Evaluation:")
    print(f"  R-squared score: {r2_val}")
    print(f"  Mean Absolute Error: {mae_val}")
    print(f"  Mean Squared Error: {mse_val}")
    print(f"  Root Mean Squared: {rmse_val}")

    print("\nTest Set Evaluation:")
    print(f"  R-squared score: {r2_test}")
    print(f"  Mean Absolute Error: {mae_test}")
    print(f"  Mean Squared Error: {mse_test}")
    print(f"  Root Mean Squared: {rmse_test}")